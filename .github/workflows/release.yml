name: "üöÄ Tauri Windows Auto Release (Tauri Version Authoritative + MSI-safe)"

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: write
  actions: read

jobs:
  build-and-release-windows:
    runs-on: windows-latest

    steps:
      # 1Ô∏è‚É£ Checkout repository (full history + tags for tagging/release)
      - name: üõí Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      # 2Ô∏è‚É£ Setup Node.js & Rust
      - name: ‚öôÔ∏è Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: ü¶Ä Setup Rust
        uses: dtolnay/rust-toolchain@stable

      # 3Ô∏è‚É£ Install project dependencies
      - name: üì¶ Install dependencies
        run: yarn install --frozen-lockfile

      # 4Ô∏è‚É£ Write raw private key as PEM
      - name: üóùÔ∏è Write private key to PEM file
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $Key = "${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}" -replace '\\n', "`n"
          $KeyPath = "src-tauri/signing_private.pem"
          Set-Content -Path $KeyPath -Value $Key -Encoding UTF8
          echo "TAURI_SIGNING_PRIVATE_KEY=$(Get-Content $KeyPath -Raw)" >> $env:GITHUB_ENV

      # 5Ô∏è‚É£ Read Tauri version and compute MSI-safe ProductVersion
      - name: üìÑ Read app version and derive MSI ProductVersion
        id: versions
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          $configPath = "src-tauri/tauri.conf.json"
          if (-not (Test-Path $configPath)) { throw "Missing $configPath" }

          $cfg = Get-Content $configPath -Raw | ConvertFrom-Json -AsHashtable
          $appVersion = $cfg['version']
          if (-not $appVersion) { throw "Missing 'version' in tauri.conf.json" }

          # Parse app version
          try {
            $ver = [version]($appVersion -replace '^v','')
          } catch {
            throw "Version must be parseable as <major>.<minor>.<build>; got '$appVersion'"
          }

          # If already within MSI limits, use as-is; else map deterministically.
          # MSI limits: major<=255, minor<=255, build<=65535.
          function Clamp($v, $max) { if ($v -lt 0) { 0 } elseif ($v -gt $max) { $max } else { $v } }

          $mMajor = $ver.Major
          $mMinor = $ver.Minor
          $mBuild = if ($ver.Build -ge 0) { $ver.Build } else { 0 }

          $withinLimits = ($mMajor -le 255 -and $mMinor -le 255 -and $mBuild -le 65535)
          if (-not $withinLimits) {
            # Date-style mapping: for years (>=2000), compress to 0-255 by subtracting 2000; otherwise clamp.
            if ($ver.Major -ge 2000 -and $ver.Major -le 2255) {
              $mMajor = $ver.Major - 2000
            } else {
              $mMajor = 255
            }
            $mMinor = Clamp $mMinor 255
            $mBuild = Clamp $mBuild 65535
          }

          $msiVersion = "$mMajor.$mMinor.$mBuild"

          echo "APP_VERSION=$appVersion" >> $env:GITHUB_ENV
          echo "RELEASE_TAG=v$appVersion" >> $env:GITHUB_ENV
          echo "MSI_VERSION=$msiVersion" >> $env:GITHUB_ENV

          Write-Host "APP_VERSION=$appVersion"
          Write-Host "RELEASE_TAG=v$appVersion"
          Write-Host "MSI_VERSION=$msiVersion"

      # 6Ô∏è‚É£ Ensure tag v{APP_VERSION} exists (no deletion/force moves)
      - name: üè∑Ô∏è Ensure tag for version
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $tag = "${{ env.RELEASE_TAG }}"
          if (git rev-parse -q --verify "refs/tags/$tag" *> $null) {
            Write-Host "Tag $tag exists."
          } else {
            git config user.name "github-actions"
            git config user.email "github-actions@github.com"
            git tag $tag
            git push origin $tag
          }

      # 7Ô∏è‚É£ Build Tauri App (inject MSI version override, keep app version unchanged)
      - name: üöÄ Build Windows release with Tauri
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ env.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          TAURI_ENV_TARGET_TRIPLE: x86_64-pc-windows-msvc
        run: |
          $ErrorActionPreference = "Stop"

          $configPath = "src-tauri/tauri.conf.json"
          $cfg = Get-Content $configPath -Raw | ConvertFrom-Json -AsHashtable

          if (-not $cfg.ContainsKey('bundle')) { $cfg['bundle'] = @{} }
          if (-not $cfg['bundle'].ContainsKey('windows')) { $cfg['bundle']['windows'] = @{} }
          if (-not $cfg['bundle']['windows'].ContainsKey('msi')) { $cfg['bundle']['windows']['msi'] = @{} }

          # Ensure correct externalBin for MSVC backend
          $cfg['bundle']['externalBin'] = @("binaries/Siribilling-backend")

          # Override MSI ProductVersion only; leave top-level 'version' as-is for app/updater.
          # Supported by the bundler as MSI-specific version override.
          $cfg['bundle']['windows']['msi']['version'] = "${{ env.MSI_VERSION }}"

          $cfg | ConvertTo-Json -Depth 20 | Out-File $configPath -Encoding UTF8

          yarn tauri build

      # 8Ô∏è‚É£ Generate latest.json (use APP_VERSION; assets under RELEASE_TAG)
      - name: üßæ Generate latest.json
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          $appVersion = "${{ env.APP_VERSION }}"
          $tag = "${{ env.RELEASE_TAG }}"
          $pubDate = Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ"
          $repo = $env:GITHUB_REPOSITORY

          $nsisDir = "src-tauri/target/release/bundle/nsis"
          if (-not (Test-Path $nsisDir)) {
            throw "NSIS bundle directory not found: $nsisDir"
          }

          $exe = Get-ChildItem -Path $nsisDir -Filter *.exe -File | Sort-Object LastWriteTime -Descending | Select-Object -First 1
          if (-not $exe) { throw "No NSIS .exe found in $nsisDir" }

          $sig = Get-ChildItem -Path $nsisDir -Filter *.sig -File | Sort-Object LastWriteTime -Descending | Select-Object -First 1
          if (-not $sig) { throw "No .sig found in $nsisDir" }
          $sigContent = Get-Content -Path $sig.FullName -Raw

          $assetNameEncoded = [System.Uri]::EscapeDataString($exe.Name)
          $assetUrl = "https://github.com/$repo/releases/download/$tag/$assetNameEncoded"

          $latestJson = @{
            version   = $appVersion
            notes     = "Windows release $tag"
            pub_date  = $pubDate
            platforms = @{
              "windows-x86_64" = @{
                url       = $assetUrl
                signature = $sigContent
              }
            }
          } | ConvertTo-Json -Depth 6

          $latestJson | Out-File -FilePath latest.json -Encoding UTF8

      # 9Ô∏è‚É£ Create release and upload all artifacts (fail fast on gh errors)
      - name: üì§ Create release and upload assets
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $ErrorActionPreference = "Stop"

          gh auth status
          if ($LASTEXITCODE -ne 0) { throw "GitHub CLI auth failed" }

          $tag = "${{ env.RELEASE_TAG }}"

          gh release view $tag -R $env:GITHUB_REPOSITORY *> $null
          if ($LASTEXITCODE -ne 0) {
            gh release create $tag --title "Windows Release $tag" --notes "Automated release" --verify-tag -R $env:GITHUB_REPOSITORY
            if ($LASTEXITCODE -ne 0) { throw "Failed to create release $tag" }
          }

          $folders = @(
            "src-tauri/target/release/bundle/msi",
            "src-tauri/target/release/bundle/nsis"
          )

          foreach ($folder in $folders) {
            if (Test-Path $folder) {
              Get-ChildItem -Path $folder -File | ForEach-Object {
                Write-Host "Uploading $($_.FullName)..."
                gh release upload $tag $_.FullName --clobber -R $env:GITHUB_REPOSITORY
                if ($LASTEXITCODE -ne 0) { throw "Failed to upload $($_.Name) to $tag" }
              }
            }
          }

          gh release upload $tag latest.json --clobber -R $env:GITHUB_REPOSITORY
          if ($LASTEXITCODE -ne 0) { throw "Failed to upload latest.json to $tag" }

          # Maintain a persistent 'latest' release WITHOUT re-tagging each run
          gh release view latest -R $env:GITHUB_REPOSITORY *> $null
          if ($LASTEXITCODE -ne 0) {
            git rev-parse -q --verify "refs/tags/latest" *> $null
            if ($LASTEXITCODE -ne 0) {
              git tag -a latest -m "Persistent latest marker"
              git push origin latest
            }

            gh release create latest --title "Latest Windows Release" --notes "Auto-synced" -R $env:GITHUB_REPOSITORY
            if ($LASTEXITCODE -ne 0) { throw "Failed to create 'latest' release" }
          }

          gh release upload latest latest.json --clobber -R $env:GITHUB_REPOSITORY
          if ($LASTEXITCODE -ne 0) { throw "Failed to upload latest.json to 'latest' release" }
